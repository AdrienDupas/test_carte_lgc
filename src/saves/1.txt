import { useEffect, useRef, useState, useCallback } from 'react'
import { Box } from '@mui/material'
import KeyboardArrowDownIcon from '@mui/icons-material/KeyboardArrowDown'
import * as d3 from 'd3'
// @ts-ignore
import { geoGinzburg9 } from 'd3-geo-projection'
import Legend from './Legend'

// Textes pour chaque étape
const stepTexts = {
  intro: "Bienvenue dans cette exploration interactive  the printing and typesetting industry. Lorem Ip the printing and typesetting industry. Lorem Ip the printing and typesetting industry. Lorem Ip the printing and typesetting industry. Lorem Ipdes grandes visions géopolitiques du XXe siècle. À travers trois étapes, découvrez comment différents penseurs ont imaginé le découpage du monde en zones d'influence économique et politique. Scrollez pour commencer votre voyage à travers l'histoire.",
  step1: "Lorem Ipsum is simply dummy text of the printing and typesetting industry. Lorem Ipsum has been the industry's standard dummy text, remaining essentially unchanged. It was popularised in the 1960s with the release of Letraset sheets containing Lorem Ipsum passages.",
  step2: "Lorem Ipsum is simply dummy text of the printing and typesetting industry. Lorem Ipsum has been the industry's standard dummy text ever since the 1500s, when an unknown printer took a galley of type and scrambled it to make a type specimen book. It has survived not only five centuries, but also the leap into electronic typesetting.",
  step3: "Lorem Ipsum is simply dummy text of the printing and typesetting industry. Lorem Ipsum has been the industry's standard dummy text ever since the 1500s. It was popularised in the 1960s with the release of Letraset sheets containing Lorem Ipsum passages, and more recently with desktop publishing software."
}

interface CountryProperties {
  NAME: string
  NAME_FR: string
  [key: string]: any
}

interface GeoFeature {
  type: string
  properties: CountryProperties
  geometry: any
}

interface GeoJSON {
  type: string
  features: GeoFeature[]
}

function App() {
  const svgRef = useRef<SVGSVGElement>(null)
  const mapContainerRef = useRef<HTMLDivElement>(null)
  const scrollContainerRef = useRef<HTMLDivElement>(null)

  const [geojsonData, setGeojsonData] = useState<GeoJSON | null>(null)
  const [world2025Data, setWorld2025Data] = useState<GeoJSON | null>(null)
  const [frontiere1939Data, setFrontiere1939Data] = useState<GeoJSON | null>(null)
  const [frontiereActuelleData, setFrontiereActuelleData] = useState<GeoJSON | null>(null)
  const [frontiereTechnatData, setFrontiereTechnatData] = useState<GeoJSON | null>(null)
  const [reseauBaseData, setReseauBaseData] = useState<GeoJSON | null>(null)
  const [basesMilitaireTechnatData, setBasesMilitaireTechnatData] = useState<GeoJSON | null>(null)
  const [technatData, setTechnatData] = useState<GeoJSON | null>(null)
  const [trumpData, setTrumpData] = useState<GeoJSON | null>(null)
  const [golfMexiqueData, setGolfMexiqueData] = useState<GeoJSON | null>(null)
  const [venezuelaData, setVenezuelaData] = useState<GeoJSON | null>(null)
  const [aireEcoData, setAireEcoData] = useState<GeoJSON | null>(null)
  const [aireEcoCatData, setAireEcoCatData] = useState<GeoJSON | null>(null)
  const [basesUsa2025Data, setBasesUsa2025Data] = useState<GeoJSON | null>(null)

  const [currentStep, setCurrentStep] = useState(0) // 0 = intro, 1, 2, 3
  const [bubbleState, setBubbleState] = useState<'visible' | 'hidden'>('visible') // État de la bulle actuelle
  const [showScrollPrompt, setShowScrollPrompt] = useState(true)
  const [isTransitioning, setIsTransitioning] = useState(false)
  const [blurAmount, setBlurAmount] = useState(3) // Flou initial en pixels
  const prevStepRef = useRef(0)
  const scrollCooldownRef = useRef(false) // Pour le délai de 1.5s entre scrolls
  const lastScrollTime = useRef(0)

  // Dériver showTechnat et showTrumpGolf depuis currentStep
  const showTechnat = currentStep >= 2
  const showTrumpGolf = currentStep >= 3

  // ======================
  // LOAD DATA
  // ======================
  useEffect(() => {
    fetch('/world.geojson').then(r => r.json()).then(setGeojsonData)
    fetch('/world_2025.geojson').then(r => r.json()).then(setWorld2025Data)
    fetch('/frontiere_1939.geojson').then(r => r.json()).then(setFrontiere1939Data)
    fetch('/frontiere_actuelle.geojson').then(r => r.json()).then(setFrontiereActuelleData)
    fetch('/frontiere_technat.geojson').then(r => r.json()).then(setFrontiereTechnatData)
    fetch('/reseau_base.geojson').then(r => r.json()).then(setReseauBaseData)
    fetch('/bases_militaire_technat.geojson').then(r => r.json()).then(setBasesMilitaireTechnatData)
    fetch('/technat.geojson').then(r => r.json()).then(setTechnatData)
    fetch('/aire_eco.geojson').then(r => r.json()).then(setAireEcoData)
    fetch('/aire_eco_cat.geojson').then(r => r.json()).then(setAireEcoCatData)

    Promise.all([
      fetch('/trump.geojson').then(r => r.json()),
      fetch('/golf_mexique.geojson').then(r => r.json()),
      fetch('/venezuela.geojson').then(r => r.json()),
      fetch('/bases_USA_2025.geojson').then(r => r.json())
    ]).then(([t, g, v, b]) => {
      setTrumpData(t)
      setGolfMexiqueData(g)
      setVenezuelaData(v)
      setBasesUsa2025Data(b)
    })
  }, [])

  // ======================
  // SCROLL DETECTION - Navigation par étapes avec délai
  // ======================
  const handleScroll = useCallback((event: WheelEvent) => {
    event.preventDefault()
    
    // Vérifier le cooldown de 1.5 secondes
    const now = Date.now()
    if (scrollCooldownRef.current || now - lastScrollTime.current < 1500) {
      return
    }

    // Masquer le prompt de scroll dès le premier scroll
    if (showScrollPrompt) {
      setShowScrollPrompt(false)
    }

    // Détecter la direction du scroll
    const scrollingDown = event.deltaY > 0

    // Activer le cooldown
    scrollCooldownRef.current = true
    lastScrollTime.current = now

    // Cas spécial pour l'intro (étape 0) : transition fluide intro → bulle 1
    if (currentStep === 0 && scrollingDown) {
      // D'abord faire disparaître l'intro vers le haut
      setBubbleState('hidden')
      setBlurAmount(0)
      // Puis après la transition, afficher la bulle 1
      setTimeout(() => {
        setCurrentStep(1)
        setBubbleState('visible')
      }, 400) // Attendre la fin de la transition (0.4s)
    } else if (bubbleState === 'visible') {
      // Si la bulle est visible, la faire se rétracter vers le haut
      setBubbleState('hidden')
      // Déflouter progressivement la carte
      setBlurAmount(0)
    } else {
      // Si la bulle est cachée, passer à l'étape suivante/précédente
      if (scrollingDown && currentStep < 3) {
        setCurrentStep(prev => prev + 1)
        setBubbleState('visible')
        setBlurAmount(0) // Pas de flou pour les nouvelles étapes
      } else if (!scrollingDown && currentStep > 0) {
        setCurrentStep(prev => prev - 1)
        setBubbleState('visible')
        if (currentStep - 1 === 0) {
          setBlurAmount(3) // Remettre le flou pour l'intro
        }
      }
    }

    // Désactiver le cooldown après 1.5 secondes
    setTimeout(() => {
      scrollCooldownRef.current = false
    }, 1500)
  }, [currentStep, showScrollPrompt, bubbleState])

  useEffect(() => {
    const container = scrollContainerRef.current
    if (!container) return

    container.addEventListener('wheel', handleScroll, { passive: false })
    return () => container.removeEventListener('wheel', handleScroll)
  }, [handleScroll])

  // ======================
  // MAP RENDER
  // ======================
  useEffect(() => {
    // Ne pas rendre tant que technatData n'est pas chargé (nécessaire pour le zoom initial)
    if (!geojsonData || !svgRef.current || !mapContainerRef.current || !technatData) return

    const container = mapContainerRef.current

    const renderMap = () => {
      const width = container.clientWidth
      const height = container.clientHeight
      if (!width || !height) return

      d3.select(svgRef.current).selectAll('*').remove()

      const svg = d3.select(svgRef.current)
        .attr('width', width)
        .attr('height', height)
        .attr('viewBox', `0 0 ${width} ${height}`)

      // Choix du fond selon l'étape
      let baseGeojson = geojsonData
      if (currentStep <= 1 && world2025Data) {
        // Étapes 0 et 1 (intro et Trump) : fond = world_2025.geojson
        baseGeojson = world2025Data
      }
      const filteredFeatures = baseGeojson.features.filter(
        f => f.properties.NAME !== 'Antarctica'
      )
      const filteredGeoJSON = {
        type: 'FeatureCollection',
        features: filteredFeatures
      }

      // Étapes 0, 1, 2 : zoom sur technatData (région Technat)
      // Étape 3 : dézoom sur le monde entier
      const shouldZoomOnTechnat = currentStep < 3
      const projection = geoGinzburg9()
        .fitSize(
          [width, height],
          shouldZoomOnTechnat ? technatData as any : filteredGeoJSON as any
        )

      const path = d3.geoPath().projection(projection)

      // ======================
      // DÉFINIR LE PATTERN DE HACHURES ROUGES FIXE
      // ======================
      const defs = svg.append('defs')
      const pattern = defs.append('pattern')
        .attr('id', 'red-hatch')
        .attr('patternUnits', 'userSpaceOnUse')
        .attr('width', 5) // réduit l'écart horizontal
        .attr('height', 5) // réduit l'écart vertical
        .attr('patternTransform', 'rotate(45)')
      
      pattern.append('line')
        .attr('x1', 0)
        .attr('y1', 0)
        .attr('x2', 0)
        .attr('y2', 7)
        .attr('stroke', '#DD203C')
        .attr('stroke-width', 3)

      // ======================
      // BASE MAP
      // ======================
      const tooltipFontSize = width < 500 ? 10 : width < 900 ? 12 : 16
      const tooltipCountry = d3.select(container)
        .selectAll('.country-tooltip')
        .data([null])
        .join('div')
        .attr('class', 'country-tooltip')
        .style('position', 'fixed')
        .style('pointer-events', 'none')
        .style('background', 'rgba(255,255,255,0.97)')
        .style('color', '#222')
        .style('border', '1.5px solid #999')
        .style('border-radius', '2px')
        .style('padding', '2px 6px')
        .style('font-family', '"Publico Text Web Regular", serif')
        .style('font-size', tooltipFontSize + 'px')
        .style('box-shadow', '0 2px 8px rgba(0,0,0,0.10)')
        .style('z-index', 3000)
        .style('opacity', 0)

      svg.append('g')
        .attr('class', 'base-countries')
        .selectAll('path')
        .data(filteredFeatures)
        .join('path')
        .attr('d', path as any)
        .attr('fill', '#e0dcdc')
        .attr('stroke', 'none')
      
      // Note: Le label Canal du Panama est maintenant rendu après les groupes Trump/Venezuela (voir plus bas)
      
      // Gestionnaire global de tooltip pour les étapes 2 et 3
      if (showTechnat) {
        svg.on('mousemove.country-tooltip', function(event) {
          const [mx, my] = d3.pointer(event, this)
          const coords = projection.invert ? projection.invert([mx, my]) : null
          
          if (coords) {
            // Trouver le pays sous la souris
            const country = filteredFeatures.find(f => {
              if (f.geometry.type === 'Polygon') {
                return d3.geoContains(f as any, coords)
              } else if (f.geometry.type === 'MultiPolygon') {
                return d3.geoContains(f as any, coords)
              }
              return false
            })
            
            if (country) {
              const tooltipNode = tooltipCountry.node() as HTMLDivElement
              if (!tooltipNode) return
              tooltipCountry.text(country.properties.NAME_FR || country.properties.NAME || '')
              const margin = 10
              const tooltipWidth = tooltipNode.offsetWidth
              const tooltipHeight = tooltipNode.offsetHeight
              let left = event.clientX + margin
              let top = event.clientY + margin
              if (left + tooltipWidth > window.innerWidth - margin)
                left = event.clientX - tooltipWidth - margin
              if (top + tooltipHeight > window.innerHeight - margin)
                top = event.clientY - tooltipHeight - margin
              tooltipCountry
                .style('left', `${left}px`)
                .style('top', `${top}px`)
                .style('opacity', 1)
            } else {
              tooltipCountry.style('opacity', 0)
            }
          }
        })
        
        svg.on('mouseleave.country-tooltip', function() {
          tooltipCountry.style('opacity', 0)
        })
      } else {
        svg.on('mousemove.country-tooltip', null)
        svg.on('mouseleave.country-tooltip', null)
        tooltipCountry.style('opacity', 0)
      }

      // ======================
      // RÉSEAU BASE (couche visible aux étapes 1 et 2)
      // ======================
      if (!showTrumpGolf && reseauBaseData) {
        svg.append('g')
          .attr('class', 'reseau-base')
          .selectAll('path')
          .data(reseauBaseData.features)
          .join('path')
          .attr('d', path as any)
          .attr('fill', 'none')
          .attr('stroke', '#bfbfbf')
          .attr('stroke-opacity', showTechnat ? 1 : 0.4)
          .attr('stroke-width', 2)
          .attr('pointer-events', 'none')
      }

      // ======================
      // FRONTIÈRES TECHNAT (couche visible aux étapes 1 et 2)
      // ======================
      if (!showTrumpGolf && frontiereTechnatData) {
        svg.append('g')
          .attr('class', 'frontieres-technat')
          .selectAll('path')
          .data(frontiereTechnatData.features)
          .join('path')
          .attr('d', path as any)
          .attr('fill', 'none')
          .attr('stroke', '#DD203C')
          .attr('stroke-opacity', showTechnat ? 1 : 0.3)
          .attr('stroke-width', 1.5)
          .attr('stroke-dasharray', '5,4')
          .attr('pointer-events', 'none')
      }

      // ======================
      // TECHNAT (étapes 1 et 2)
      // ======================
      if (!showTrumpGolf && technatData) {
        svg.append('g')
          .attr('class', 'technat')
          .selectAll('path')
          .data(technatData.features)
          .join('path')
          .attr('d', path as any)
          .attr('fill', '#DD203C')
          .attr('fill-opacity', showTechnat ? 0.8 : 0.2)
      }

      // ======================
      // TRUMP + VENEZUELA (ÉTAPE 1)
      // ======================
      if (!showTechnat && trumpData && venezuelaData) {
        const trump = svg.append('g')
        trump.selectAll('path')
          .data(trumpData.features)
          .join('path')
          .attr('d', path as any)
          .attr('fill', '#DD203C')
          .attr('fill-opacity', 0.8)
          .attr('stroke', d => 
            d.properties.NAME === 'Canal de Panama' ? '#DD203C' : 'none'
          )
          .attr('stroke-width', d => 
            d.properties.NAME === 'Canal de Panama' ? 10 : 0)
           .attr('stroke-linecap', 'round')
          .attr('stroke-linejoin', 'round')

        const venezuela = svg.append('g')
        venezuela.selectAll('path')
          .data(venezuelaData.features)
          .join('path')
          .attr('d', path as any)
          .attr('fill', 'url(#red-hatch)')
          .attr('stroke', 'none')

        // Affichage des bases USA 2025
        if (basesUsa2025Data) {
          const baseRadius = width < 500 ? 4 : width < 900 ? 5 : 7
          svg.append('g')
            .attr('class', 'bases-usa-2025')
            .selectAll('circle')
            .data(basesUsa2025Data.features)
            .join('circle')
            .attr('cx', d => {
              const coords = projection(d.geometry.coordinates as [number, number])
              return coords ? coords[0] : 0
            })
            .attr('cy', d => {
              const coords = projection(d.geometry.coordinates as [number, number])
              return coords ? coords[1] : 0
            })
            .attr('r', baseRadius)
            .attr('fill', '#0052cc')
            .attr('fill-opacity', 0.85)
            .attr('stroke', '#fff')
            .attr('stroke-width', 2)
        }
      }

      // ======================
      // CANAL DE PANAMA LINE AND LABEL (ÉTAPE 3)
      // Placé après les groupes Trump/Venezuela pour être au-dessus dans l'ordre de rendu
      // ======================
      // Note: Le code du label Canal du Panama a été déplacé plus bas, après les frontières et bases

      // ======================
      // FRONTIÈRES (1939 ou actuelles avec transition)
      // Affichées au-dessus de toutes les autres couches
      // ======================
      // AIRE ECO CAT (uniquement étape 3) - EN DESSOUS DES FRONTIÈRES
      if (showTechnat && showTrumpGolf && aireEcoCatData) {
        const aireEcoCatGroup = svg.append('g')
          .attr('class', 'aire-eco-cat')
        aireEcoCatGroup
          .selectAll('path')
          .data(aireEcoCatData.features)
          .join('path')
          .attr('d', path as any)
          .attr('fill', d => d.properties.cat === 1 ? '#6d000d' : '#DD203C')
          .attr('fill-opacity', 0.8)
          .attr('stroke', 'none')
          .attr('stroke-width', 0)
          .attr('pointer-events', 'none')
      }

      // Frontières 1939 (visibles étape 3 uniquement)
      const borderStrokeWidth = width < 600 ? 0.8 : width < 900 ? 1 : 1.2
      if (frontiere1939Data && showTechnat && showTrumpGolf) {
        const g1939 = svg.append('g')
          .attr('class', 'frontieres-1939')

        g1939.selectAll('path')
          .data(frontiere1939Data.features)
          .join('path')
          .attr('d', path as any)
          .attr('fill', 'none')
          .attr('stroke', '#ffffff')
          .attr('stroke-width', borderStrokeWidth)
          .attr('pointer-events', 'none')
      }

      // ======================
      // AIRE ECO (uniquement étape 3) - AU-DESSUS DES FRONTIÈRES
      // ======================
      if (showTechnat && showTrumpGolf && aireEcoData) {
        const aireEcoGroup = svg.append('g')
          .attr('class', 'aire-eco')
        aireEcoGroup
          .selectAll('path')
          .data(aireEcoData.features)
          .join('path')
          .attr('d', path as any)
          .attr('fill', 'none')
          .attr('stroke', '#df5757')
          .attr('stroke-width', 1.5)
          .attr('pointer-events', 'none')
      }

      
      // Frontières actuelles (visibles étapes 1 et 2)
      if (!showTrumpGolf && frontiereActuelleData) {
        const gActuelle = svg.append('g')
          .attr('class', 'frontieres-actuelles')
          .style('opacity', 1)

        gActuelle.selectAll('path')
          .data(frontiereActuelleData.features)
          .join('path')
          .attr('d', path as any)
          .attr('fill', 'none')
          .attr('stroke', '#ffffff')
          .attr('stroke-width', borderStrokeWidth)
          .attr('pointer-events', 'none')
      }

      // ======================
      // AIRE ECO PALE (uniquement étapes 1 et 2) - Superposition pâle
      // ======================
      if (!showTrumpGolf && aireEcoData) {
        const aireEcoGroupPale = svg.append('g')
          .attr('class', 'aire-eco-pale')
        aireEcoGroupPale
          .selectAll('path')
          .data(aireEcoData.features)
          .join('path')
          .attr('d', path as any)
          .attr('fill', 'none')
          .attr('stroke', '#e23434')
          .attr('stroke-width', 1.5)
          .attr('stroke-opacity', 0.3)
          .attr('pointer-events', 'none')
      }

      // ======================
      // BASES MILITAIRES TECHNAT (couche ponctuelle - étapes 1 et 2)
      // ======================
      if (!showTrumpGolf && basesMilitaireTechnatData) {
        // Rayon responsive selon la largeur de la fenêtre
        const baseRadius = width < 500 ? 4 : width < 900 ? 5 : 7
        // Font size responsive pour le tooltip
        const tooltipFontSize = width < 500 ? 10 : width < 900 ? 12 : 16
        const tooltip = d3.select(container)
          .selectAll('.military-tooltip')
          .data([null])
          .join('div')
          .attr('class', 'military-tooltip')
          .style('position', 'fixed')
          .style('pointer-events', 'none')
          .style('background', 'rgba(255,255,255,0.97)')
          .style('color', '#222')
          .style('border', '1.5px solid #DD203C')
          .style('border-radius', '2px')
          .style('padding', '2px 6px')
          .style('font-family', '"Publico Text Web Regular", serif')
          .style('font-size', tooltipFontSize + 'px')
          .style('box-shadow', '0 2px 8px rgba(0,0,0,0.10)')
          .style('z-index', 3000)
          .style('opacity', 0)

        svg.append('g')
          .attr('class', 'bases-militaires-technat')
          .selectAll('circle')
          .data(basesMilitaireTechnatData.features)
          .join('circle')
          .attr('cx', d => {
            const coords = projection(d.geometry.coordinates as [number, number])
            return coords ? coords[0] : 0
          })
          .attr('cy', d => {
            const coords = projection(d.geometry.coordinates as [number, number])
            return coords ? coords[1] : 0
          })
          .attr('r', baseRadius)
          .attr('fill', '#DD203C')
          .attr('fill-opacity', showTechnat ? 1 : 0.3)
          .attr('stroke', '#ffffff')
          .attr('stroke-opacity', showTechnat ? 1 : 0.3)
          .attr('stroke-width', 2)
          .on('mousemove', function(event, d) {
            // Masquer le tooltip des pays (priorité aux bases)
            d3.selectAll('.country-tooltip').style('opacity', 0)
            const tooltipNode = tooltip.node() as HTMLDivElement
            if (!tooltipNode) return
            tooltip.text(d.properties.NAME_CITY || 'militaire')
            const margin = 10
            const tooltipWidth = tooltipNode.offsetWidth
            const tooltipHeight = tooltipNode.offsetHeight
            let left = event.clientX + margin
            let top = event.clientY + margin
            if (left + tooltipWidth > window.innerWidth - margin)
              left = event.clientX - tooltipWidth - margin
            if (top + tooltipHeight > window.innerHeight - margin)
              top = event.clientY - tooltipHeight - margin
            tooltip
              .style('left', `${left}px`)
              .style('top', `${top}px`)
              .style('opacity', 1)
          })
          .on('mouseleave', function() {
            tooltip.style('opacity', 0)
          })
          .on('mouseenter', function(event, d) {
            // Masquer le tooltip des pays (priorité aux bases)
            d3.selectAll('.country-tooltip').style('opacity', 0)
            const tooltipNode = tooltip.node() as HTMLDivElement
            if (!tooltipNode) return
            tooltip.text(d.properties.NAME_CITY || 'militaire')
            const margin = 10
            const tooltipWidth = tooltipNode.offsetWidth
            const tooltipHeight = tooltipNode.offsetHeight
            let left = event.clientX + margin
            let top = event.clientY + margin
            if (left + tooltipWidth > window.innerWidth - margin)
              left = event.clientX - tooltipWidth - margin
            if (top + tooltipHeight > window.innerHeight - margin)
              top = event.clientY - tooltipHeight - margin
            tooltip
              .style('left', `${left}px`)
              .style('top', `${top}px`)
              .style('opacity', 1)
          })

        // Tooltip affiché uniquement lors du survol direct d'un cercle (plus de tooltip à proximité)
      }

      // ======================
      // BASES USA 2025 (étape 1 - au-dessus des bases militaires technat)
      // ======================
      if (!showTechnat && basesUsa2025Data) {
        const baseRadius = width < 500 ? 4 : width < 900 ? 5 : 7
        const tooltipFontSize = width < 500 ? 10 : width < 900 ? 12 : 16
        const tooltipUsa = d3.select(container)
          .selectAll('.usa-tooltip')
          .data([null])
          .join('div')
          .attr('class', 'usa-tooltip')
          .style('position', 'fixed')
          .style('pointer-events', 'none')
          .style('background', 'rgba(255,255,255,0.97)')
          .style('color', '#222')
          .style('border', '1.5px solid #4991d9')
          .style('border-radius', '2px')
          .style('padding', '2px 6px')
          .style('font-family', '"Publico Text Web Regular", serif')
          .style('font-size', tooltipFontSize + 'px')
          .style('box-shadow', '0 2px 8px rgba(0,0,0,0.10)')
          .style('z-index', 3000)
          .style('opacity', 0)

        svg.append('g')
          .attr('class', 'bases-usa-2025')
          .selectAll('circle')
          .data(basesUsa2025Data.features)
          .join('circle')
          .attr('cx', d => {
            const coords = projection(d.geometry.coordinates as [number, number])
            return coords ? coords[0] : 0
          })
          .attr('cy', d => {
            const coords = projection(d.geometry.coordinates as [number, number])
            return coords ? coords[1] : 0
          })
          .attr('r', baseRadius)
          .attr('fill', '#4991d9')
          .attr('fill-opacity', 0.85)
          .attr('stroke', '#fff')
          .attr('stroke-width', 2)
          .on('mousemove', function(event, d) {
            // Masquer le tooltip des pays (priorité aux bases)
            d3.selectAll('.country-tooltip').style('opacity', 0)
            const tooltipNode = tooltipUsa.node() as HTMLDivElement
            if (!tooltipNode) return
            tooltipUsa.text(d.properties.NAME_CITY || 'USA')
            const margin = 10
            const tooltipWidth = tooltipNode.offsetWidth
            const tooltipHeight = tooltipNode.offsetHeight
            let left = event.clientX + margin
            let top = event.clientY + margin
            if (left + tooltipWidth > window.innerWidth - margin)
              left = event.clientX - tooltipWidth - margin
            if (top + tooltipHeight > window.innerHeight - margin)
              top = event.clientY - tooltipHeight - margin
            tooltipUsa
              .style('left', `${left}px`)
              .style('top', `${top}px`)
              .style('opacity', 1)
          })
          .on('mouseleave', function() {
            tooltipUsa.style('opacity', 0)
          })
          .on('mouseenter', function(event, d) {
            // Masquer le tooltip des pays (priorité aux bases)
            d3.selectAll('.country-tooltip').style('opacity', 0)
            const tooltipNode = tooltipUsa.node() as HTMLDivElement
            if (!tooltipNode) return
            tooltipUsa.text(d.properties.NAME_CITY || 'USA')
            const margin = 10
            const tooltipWidth = tooltipNode.offsetWidth
            const tooltipHeight = tooltipNode.offsetHeight
            let left = event.clientX + margin
            let top = event.clientY + margin
            if (left + tooltipWidth > window.innerWidth - margin)
              left = event.clientX - tooltipWidth - margin
            if (top + tooltipHeight > window.innerHeight - margin)
              top = event.clientY - tooltipHeight - margin
            tooltipUsa
              .style('left', `${left}px`)
              .style('top', `${top}px`)
              .style('opacity', 1)
          })

        // Affichage du tooltip à proximité (zone de tolérance)
        svg.on('mousemove.usa-bases-tooltip', function(event) {
          const [mx, my] = d3.pointer(event, this)
          const tooltipNode = tooltipUsa.node() as HTMLDivElement
          if (!tooltipNode) return
          let found = false
          basesUsa2025Data.features.forEach(d => {
            const coords = projection(d.geometry.coordinates as [number, number])
            if (coords) {
              const dx = coords[0] - mx
              const dy = coords[1] - my
              const dist = Math.sqrt(dx*dx + dy*dy)
              if (dist < baseRadius + 8) {
                // Masquer le tooltip des pays seulement si on trouve une base à proximité
                d3.selectAll('.country-tooltip').style('opacity', 0)
                tooltipUsa.text(d.properties.NAME_CITY || 'USA')
                const margin = 10
                const tooltipWidth = tooltipNode.offsetWidth
                const tooltipHeight = tooltipNode.offsetHeight
                let left = event.clientX + margin
                let top = event.clientY + margin
                if (left + tooltipWidth > window.innerWidth - margin)
                  left = event.clientX - tooltipWidth - margin
                if (top + tooltipHeight > window.innerHeight - margin)
                  top = event.clientY - tooltipHeight - margin
                tooltipUsa
                  .style('left', `${left}px`)
                  .style('top', `${top}px`)
                  .style('opacity', 1)
                found = true
              }
            }
          })
          if (!found) {
            tooltipUsa.style('opacity', 0)
          }
        })
        svg.on('mouseleave.usa-bases-tooltip', function() {
          tooltipUsa.style('opacity', 0)
        })
      }

      // ======================
      // CANAL DE PANAMA LABEL - AU-DESSUS DE TOUT (étape 1)
      // ======================
      if (!showTechnat && trumpData && venezuelaData) {
        const canalFeature = trumpData.features.find(f => f.properties.NAME === 'Canal de Panama')
        if (canalFeature) {
          const canalCentroid = d3.geoCentroid(canalFeature as any)
          const canalCoords = projection(canalCentroid)
          if (canalCoords) {
            // Décaler le label en bas du canal
            const labelOffsetY = 45; // valeur positive pour aller vers le bas
            // Dessiner le trait du canal vers le label en bas avec des extrémités arrondies
            svg.append('g')
              .attr('class', 'canal-panama-line')
              .append('line')
              .attr('x1', canalCoords[0])
              .attr('y1', canalCoords[1])
              .attr('x2', canalCoords[0])
              .attr('y2', canalCoords[1] + labelOffsetY - 10)
              .attr('stroke', '#DD203C')
              .attr('stroke-width', 2)
             
            // Label avec double contour blanc positionné en bas du canal
            const labelFontSize = width < 600 ? 11 : width < 900 ? 12 : 16
            const labelGroup = svg.append('g')
              .attr('class', 'canal-panama-label')
            // Contour blanc externe
            labelGroup.append('text')
              .attr('x', canalCoords[0])
              .attr('y', canalCoords[1] + labelOffsetY)
              .text('Canal de Panama')
              .attr('font-family', '"Publico Text Web Regular", serif')
              .attr('font-size', labelFontSize)
              .attr('fill', 'none')
              .attr('font-weight', 'bold')
              .attr('text-anchor', 'middle')
              .attr('alignment-baseline', 'middle')
              .attr('stroke', 'white')
              .attr('stroke-width', 4)
            
            // Texte rouge au-dessus
            labelGroup.append('text')
              .attr('x', canalCoords[0])
              .attr('y', canalCoords[1] + labelOffsetY)
              .text('Canal de Panama')
              .attr('font-family', '"Publico Text Web Regular", serif')
              .attr('font-size', labelFontSize)
              .attr('fill', '#DD203C')
              .attr('font-weight', 'bold')
              .attr('text-anchor', 'middle')
              .attr('alignment-baseline', 'middle')
          }
        }
      }

      // ======================
      // LABELS DES PAYS (ÉTAPES 1 ET 2)
      // ======================
      if (!showTrumpGolf) {
        const countryLabels = !showTechnat 
          ? [
              { label: 'États-Unis', nameFr: 'États-Unis' },
              { label: 'Canada', nameFr: 'Canada' },
              { label: 'Mexique', nameFr: 'Mexique' },
              { label: 'Groenland', nameFr: 'Groenland' },
              { label: 'Venezuela', nameFr: 'Venezuela' }
            ]
          : [
              { label: 'États-Unis', nameFr: 'États-Unis' },
              { label: 'Canada', nameFr: 'Canada' },
              { label: 'Mexique', nameFr: 'Mexique' },
              { label: 'Groenland', nameFr: 'Groenland' },
              { label: 'Venezuela', nameFr: 'Venezuela' },
              { label: 'Colombie', nameFr: 'Colombie' }
            ]

        const labelFontSize = width < 600 ? 11 : width < 900 ? 14 : 18

        countryLabels.forEach(({ label, nameFr }) => {
          const country = filteredFeatures.find(f => f.properties.NAME_FR === nameFr)
          if (country) {
            const centroid = d3.geoCentroid(country as any)
            const coords = projection(centroid)
            if (coords) {
              // Décalages pour certains pays
              let offsetX = 0
              let offsetY = 0
              if (label === 'Canada') {
                offsetX = -40
              } else if (label === 'Venezuela') {
                offsetX = 10
                offsetY = -10
              }
              
              const labelGroup = svg.append('g')
                .attr('class', `country-label-${label}`)
              
              // Contour rouge
              labelGroup.append('text')
                .attr('x', coords[0] + offsetX)
                .attr('y', coords[1] + offsetY)
                .text(label)
                .attr('font-family', '"Sanomat Web Medium Regular", serif')
                .attr('font-size', labelFontSize)
                .attr('font-weight', 'bold')
                .attr('fill', 'none')
                .attr('text-anchor', 'middle')
                .attr('alignment-baseline', 'middle')
                .attr('stroke', '#DD203C')
                .attr('stroke-width', 3)
                .attr('stroke-linejoin', 'round')
                .attr('stroke-linecap', 'round')
              
              // Texte blanc
              labelGroup.append('text')
                .attr('x', coords[0] + offsetX)
                .attr('y', coords[1] + offsetY)
                .text(label)
                .attr('font-family', '"Sanomat Web Medium Regular", serif')
                .attr('font-size', labelFontSize)
                .attr('font-weight', 'bold')
                .attr('fill', '#ffffff')
                .attr('text-anchor', 'middle')
                .attr('alignment-baseline', 'middle')
            }
          }
        })
      }

      // ======================
      // NOMS DES OCÉANS
      // ======================
      const oceans = [
        { name: 'Océan\nPacifique', coords: [-140, 10] },
        { name: 'Océan\nAtlantique', coords: [-60, 25] },
        { name: 'Océan\nIndien', coords: [75, -20] },
        { name: 'Océan\nArctique', coords: [-5, 80] }
      ]

      const oceanFontSize = width < 600 ? 10 : width < 900 ? 12 : 16

      const oceanGroup = svg.append('g')
        .attr('class', 'ocean-labels')
        .style('opacity', 1)

      oceans.forEach(ocean => {
        const coords = projection(ocean.coords as [number, number])
        if (coords) {
          const lines = ocean.name.split('\n')
          // Contour blanc (double stroke)
          lines.forEach((line, i) => {
            oceanGroup.append('text')
              .attr('class', `ocean-${ocean.coords[0]}-${ocean.coords[1]}-${i}`)
              .attr('x', coords[0])
              .attr('y', coords[1] + i * (oceanFontSize + 2))
              .attr('text-anchor', 'start')
              .attr('font-family', '"Open Sans", sans-serif')
              .attr('font-size', oceanFontSize)
              .attr('font-weight', 400)
              .attr('font-style', 'italic')
              .attr('fill', 'none')
              .attr('stroke', '#ffffff')
              .attr('stroke-width', 7)
              .attr('stroke-linejoin', 'round')
              .attr('stroke-linecap', 'round')
              .attr('opacity', 0.9)
              .text(line)
          })
          // Texte gris principal
          lines.forEach((line, i) => {
            oceanGroup.append('text')
              .attr('class', `ocean-${ocean.coords[0]}-${ocean.coords[1]}-${i}`)
              .attr('x', coords[0])
              .attr('y', coords[1] + i * (oceanFontSize + 2))
              .attr('text-anchor', 'start')
              .attr('font-family', '"Open Sans", sans-serif')
              .attr('font-size', oceanFontSize)
              .attr('font-weight', 400)
              .attr('font-style', 'italic')
              .attr('fill', '#999999')
              .attr('opacity', 0.7)
              .text(line)
          })
        }
      })
    }

    renderMap()
    window.addEventListener('resize', renderMap)
    return () => window.removeEventListener('resize', renderMap)

  }, [
    geojsonData,
    frontiere1939Data,
    frontiereActuelleData,
    frontiereTechnatData,
    reseauBaseData,
    basesMilitaireTechnatData,
    technatData,
    trumpData,
    golfMexiqueData,
    aireEcoData,
    aireEcoCatData,
    showTechnat,
    showTrumpGolf,
    currentStep
  ])

  // ======================
  // TRANSITION DE DÉZOOM ENTRE ÉTAPE 2 ET 3
  // ======================
  useEffect(() => {
    if (!svgRef.current || !mapContainerRef.current || !technatData || !geojsonData) return
    if (isTransitioning) return

    const container = mapContainerRef.current
    const svg = d3.select(svgRef.current)
    const width = container.clientWidth
    const height = container.clientHeight

    // Préparer les données filtrées
    let baseGeojson = geojsonData
    if (currentStep <= 1 && world2025Data) {
      baseGeojson = world2025Data
    }
    const filteredFeatures = baseGeojson.features.filter(
      f => f.properties.NAME !== 'Antarctica'
    )
    const filteredGeoJSON = {
      type: 'FeatureCollection',
      features: filteredFeatures
    }

    // Ne faire la transition QUE si on passe de l'étape 2 à 3 ou de 3 à 2
    const transitionNeeded = (prevStepRef.current === 2 && currentStep === 3) || 
                            (prevStepRef.current === 3 && currentStep === 2)
    
    prevStepRef.current = currentStep
    
    if (!transitionNeeded) return

    setIsTransitioning(true)

    // Définir les projections de départ et d'arrivée
    const start = geoGinzburg9().fitSize([width, height], technatData as any)
    const end = geoGinzburg9().fitSize([width, height], filteredGeoJSON as any)

    const scaleI = d3.interpolate(
      currentStep === 3 ? start.scale() : end.scale(),
      currentStep === 3 ? end.scale() : start.scale()
    )
    const translateI = d3.interpolate(
      currentStep === 3 ? start.translate() : end.translate(),
      currentStep === 3 ? end.translate() : start.translate()
    )

    // Noms des océans pour mise à jour pendant la transition
    const oceans = [
      { name: 'Océan\nPacifique', coords: [-140, 10] },
      { name: 'Océan\nAtlantique', coords: [-60, 25] },
      { name: 'Océan\nIndien', coords: [75, -20] },
      { name: 'Océan\nArctique', coords: [-5, 80] }
    ]
    const oceanFontSize = width < 600 ? 10 : width < 900 ? 12 : 16

    svg.transition()
      .duration(500)
      .ease(d3.easeQuadInOut)
      .tween('zoom', () => (t: number) => {
        const p = geoGinzburg9()
          .scale(scaleI(t))
          .translate(translateI(t))

        const tempPath = d3.geoPath().projection(p)
        
        // Mettre à jour tous les paths
        svg.selectAll<SVGPathElement, any>('path')
          .attr('d', tempPath as any)
        
        // Mettre à jour les cercles (bases militaires)
        svg.selectAll<SVGCircleElement, GeoFeature>('circle')
          .attr('cx', d => {
            const coords = p(d.geometry.coordinates as [number, number])
            return coords ? coords[0] : 0
          })
          .attr('cy', d => {
            const coords = p(d.geometry.coordinates as [number, number])
            return coords ? coords[1] : 0
          })
        
        // Mettre à jour les positions des textes des océans
        oceans.forEach(ocean => {
          const coords = p(ocean.coords as [number, number])
          if (coords) {
            const lines = ocean.name.split('\n')
            lines.forEach((_, i) => {
              svg.selectAll(`.ocean-${ocean.coords[0]}-${ocean.coords[1]}-${i}`)
                .attr('x', coords[0])
                .attr('y', coords[1] + i * (oceanFontSize + 2))
            })
          }
        })

        // Mettre à jour les labels des pays
        const countryLabels = [
          { label: 'États-Unis', nameFr: 'États-Unis', offsetX: 0, offsetY: 0 },
          { label: 'Canada', nameFr: 'Canada', offsetX: -40, offsetY: 0 },
          { label: 'Mexique', nameFr: 'Mexique', offsetX: 0, offsetY: 0 },
          { label: 'Groenland', nameFr: 'Groenland', offsetX: 0, offsetY: 0 },
          { label: 'Venezuela', nameFr: 'Venezuela', offsetX: 10, offsetY: -10 },
          { label: 'Colombie', nameFr: 'Colombie', offsetX: 0, offsetY: 0 }
        ]
        
        countryLabels.forEach(({ label, nameFr, offsetX, offsetY }) => {
          const country = filteredFeatures.find(f => f.properties.NAME_FR === nameFr)
          if (country) {
            const centroid = d3.geoCentroid(country as any)
            const coords = p(centroid)
            if (coords) {
              svg.selectAll(`.country-label-${label} text`)
                .attr('x', coords[0] + offsetX)
                .attr('y', coords[1] + offsetY)
            }
          }
        })

        // Mettre à jour le label du Canal de Panama si présent
        if (trumpData) {
          const canalFeature = trumpData.features.find(f => f.properties.NAME === 'Canal de Panama')
          if (canalFeature) {
            const canalCentroid = d3.geoCentroid(canalFeature as any)
            const canalCoords = p(canalCentroid)
            if (canalCoords) {
              const labelOffsetY = 45
              svg.select('.canal-panama-line line')
                .attr('x1', canalCoords[0])
                .attr('y1', canalCoords[1])
                .attr('x2', canalCoords[0])
                .attr('y2', canalCoords[1] + labelOffsetY - 10)
              
              svg.selectAll('.canal-panama-label text')
                .attr('x', canalCoords[0])
                .attr('y', canalCoords[1] + labelOffsetY)
            }
          }
        }
      })
      .on('end', () => {
        setIsTransitioning(false)
      })

  }, [currentStep, technatData, geojsonData, world2025Data, trumpData, isTransitioning])

  // Obtenir le titre et la source selon l'étape
  const getTitle = () => {
    if (currentStep <= 1) return 'Les revendications des États-Unis'
    if (currentStep === 2) return 'Le Technat'
    return 'Economies de grands espaces (Großraumwirtschaften)'
  }

  const getSubtitle = () => {
    if (currentStep <= 1) return 'Donald Trump, 2025-2026'
    if (currentStep === 2) return 'Howard Scott, 1940'
    return 'Ferdinand Fried, 1940'
  }

  const getSource = () => {
    if (currentStep <= 1) return 'Donald Trump, X, 2025-2026'
    if (currentStep === 2) return 'Howard Scott, 1940'
    return 'Fried Ferdinand, Das XX. Jahrhundert, 1940'
  }

  return (
    <Box 
      ref={scrollContainerRef}
      sx={{ 
        width: '100vw', 
        height: '100vh', 
        overflow: 'hidden',
        position: 'relative',
      }}
    >
      {/* Carte fixe en arrière-plan */}
      <Box sx={{ 
        position: 'sticky',
        top: 0,
        left: 0,
        width: '100%', 
        height: '100vh',
        display: 'flex', 
        flexDirection: 'column',
        zIndex: 1
      }}>
        {/* Header - au-dessus du flou */}
        <Box sx={{ 
          width: '100%', 
          display: 'flex', 
          flexDirection: 'column',
          alignItems: 'flex-start', 
          justifyContent: 'center',
          px: 1.2,
          pb: 1,
          pt: 1,
          backgroundColor: 'rgba(255, 255, 255, 0.95)',
          color: 'black',
          gap: 0.5,
          zIndex: 100,
          flexShrink: 0,
          filter: `blur(${blurAmount}px)`,
          transition: 'filter 0.5s ease-out',
          position: 'relative',
        }}>
          <Box sx={{ display: 'flex', gap: 1, alignItems: 'center' }}>
            <Box sx={{ 
              fontFamily: '"Sanomat Web Medium Regular"',
              fontSize: { xs: '14px', sm: '19px', md: '23px' },
              fontWeight: 'bold',
              transition: 'all 0.3s ease'
            }}>
              {getTitle()}
            </Box>
            <Box sx={{ 
              fontFamily: '"Publico Text Web Regular"',
              fontSize: { xs: '12px', sm: '15px', md: '19px' },
              transition: 'all 0.3s ease'
            }}>
              {getSubtitle()}
            </Box>
          </Box>
        </Box>

        {/* Map container */}
        <Box ref={mapContainerRef} sx={{ 
          width: '100%', 
          flexGrow: 1, 
          minHeight: 0, 
          position: 'relative',
          filter: `blur(${blurAmount}px)`,
          transition: 'filter 0.5s ease-out'
        }}>
          <svg ref={svgRef} style={{ width: '100%', height: '100%' }} />
          
          {/* Indicateur pour continuer à explorer */}
          {!showScrollPrompt && bubbleState === 'hidden' && (
            <Box
              sx={{
                position: 'absolute',
                left: { xs: 12, md: 16 },
                top: { xs: 12, md: 16 },
                bgcolor: 'rgba(255,255,255,0.95)',
                px: { xs: 1.5, sm: 2, md: 2.5 },
                py: { xs: 0.8, sm: 1, md: 1.2 },
                borderRadius: 6,
                boxShadow: '0 2px 10px rgba(0,0,0,0.1)',
                fontSize: { xs: '10px', sm: '12px', md: '13px' },
                color: '#666',
                fontFamily: '"Open Sans", sans-serif',
                animation: 'pulseSubtle 2.5s ease-in-out infinite',
                '@keyframes pulseSubtle': {
                  '0%': { opacity: 0.6, transform: 'scale(1)' },
                  '50%': { opacity: 0.9, transform: 'scale(1.03)' },
                  '100%': { opacity: 0.6, transform: 'scale(1)' },
                },
                zIndex: 101,
                textAlign: 'center',
                display: 'flex',
                alignItems: 'center',
                gap: 0.6,
                pointerEvents: 'none',
              }}
            >
              {currentStep < 3 ? (
                <>
                  Scrollez
                  <KeyboardArrowDownIcon 
                    sx={{ 
                      fontSize: { xs: '16px', sm: '18px', md: '20px' },
                      color: '#DD203C',
                    }}
                  />
                </>
              ) : (
                <>
                  Revenez
                  <Box 
                    sx={{ 
                      fontSize: { xs: '16px', sm: '18px', md: '20px' },
                      color: '#DD203C',
                      transform: 'rotate(180deg)',
                      display: 'flex',
                      alignItems: 'center',
                    }}
                  >
                    <KeyboardArrowDownIcon 
                      sx={{ 
                        fontSize: { xs: '16px', sm: '18px', md: '20px' },
                      }}
                    />
                  </Box>
                </>
              )}
            </Box>
          )}
          
          {/* Source en bas au centre */}
          <Box
            sx={{
              position: 'absolute',
              bottom: 4,
              left: '50%',
              transform: 'translateX(-50%)',
              color: '#666',
              fontFamily: '"Publico Text Web Regular", serif',
              fontSize: { xs: '9px', md: '11px' },
              zIndex: 1000,
              fontStyle: 'italic',
              transition: 'all 0.3s ease'
            }}
          >
            Source: {getSource()}
          </Box>
        </Box>
        

        
        {/* Barre de progression */}
        <Box sx={{ 
          width: '100%', 
          height: { xs: '4px', sm: '6px', md: '8px' }, 
          backgroundColor: 'rgba(200, 200, 200, 0.4)',
          flexShrink: 0,
          position: 'relative',
          overflow: 'hidden'
        }}>
          <Box sx={{ 
            height: '100%',
            width: currentStep === 0 ? '0%' : currentStep === 1 ? '33.33%' : currentStep === 2 ? '66.66%' : '100%',
            backgroundColor: '#DD203C',
            transition: 'width 0.8s ease-in-out',
            boxShadow: '0 0 8px rgba(221, 32, 60, 0.5)'
          }} />
        </Box>
        
        {/* Legend */}
        <Box sx={{ 
          width: '100%', 
          minHeight: { xs: '150px', sm: '100px', md: '104px' }, 
          flexShrink: 0,
          filter: `blur(${blurAmount}px)`,
          transition: 'filter 0.5s ease-out'
        }}>
          <Legend showTechnat={showTechnat} showTrumpGolf={showTrumpGolf} />
        </Box>
      </Box>

      {/* Bulle de texte animée - se rétracte vers le haut */}
      <Box
        sx={{
          position: 'absolute',
          top: bubbleState === 'visible' ? '0' : '-100%',
          left: 0,
          width: '100%',
          display: 'flex',
          justifyContent: 'center',
          zIndex: 20,
          transition: 'top 0.4s ease-in-out',
          pointerEvents: bubbleState === 'visible' ? 'auto' : 'none',
        }}
      >
        <Box
          sx={{
            width: { xs: '100%', sm: '80%', md: '50%' },
            maxHeight: '80vh',
            overflow: 'auto',
            bgcolor: 'rgba(255,255,255,0.97)',
            px: { xs: 2, sm: 3, md: 4 },
            py: { xs: 2.5, sm: 3, md: 4 },
            boxShadow: '0 4px 20px rgba(0,0,0,0.15)',
            fontSize: { xs: '14px', sm: '16px', md: '18px' },
            lineHeight: 1.8,
            color: '#1b1b1b',
            fontFamily: '"Publico Text Web Regular", serif',
          }}
        >
          {/* Contenu de l'intro */}
          {currentStep === 0 && (
            <>
              <Box sx={{ 
                fontFamily: '"Sanomat Web Medium Regular"',
                fontSize: { xs: '18px', sm: '22px', md: '26px' },
                fontWeight: 'bold',
                mb: 2,
                color: '#DD203C'
              }}>
                Introduction
              </Box>
              {stepTexts.intro}
              <Box sx={{
                display: 'flex',
                flexDirection: 'column',
                alignItems: 'center',
                gap: 1,
                mt: 3,
                color: '#DD203C',
                fontWeight: 600,
                fontSize: { xs: '15px', sm: '17px', md: '19px' },
                letterSpacing: 0.2,
                userSelect: 'none',
              }}>
                Scrollez pour explorer
                <KeyboardArrowDownIcon 
                  sx={{ 
                    fontSize: { xs: '28px', sm: '32px', md: '36px' },
                    color: '#DD203C',
                    animation: 'bounce 1.5s ease-in-out infinite',
                    '@keyframes bounce': {
                      '0%, 100%': { transform: 'translateY(0)' },
                      '50%': { transform: 'translateY(8px)' },
                    },
                  }}
                />
              </Box>
            </>
          )}

          {/* Contenu étape 1 */}
          {currentStep === 1 && (
            <>
              <Box sx={{ 
                fontFamily: '"Sanomat Web Medium Regular"',
                fontSize: { xs: '16px', sm: '20px', md: '24px' },
                fontWeight: 'bold',
                mb: 2,
                color: '#DD203C'
              }}>
                Les revendications de Trump
              </Box>
              {stepTexts.step3}
              <Box sx={{
                display: 'flex',
                justifyContent: 'center',
                mt: 3,
              }}>
                <KeyboardArrowDownIcon 
                  sx={{ 
                    fontSize: { xs: '28px', sm: '32px', md: '36px' },
                    color: '#DD203C',
                    animation: 'bounce 1.5s ease-in-out infinite',
                  }}
                />
              </Box>
            </>
          )}

          {/* Contenu étape 2 */}
          {currentStep === 2 && (
            <>
              <Box sx={{ 
                fontFamily: '"Sanomat Web Medium Regular"',
                fontSize: { xs: '16px', sm: '20px', md: '24px' },
                fontWeight: 'bold',
                mb: 2,
                color: '#DD203C'
              }}>
                Le Technat
              </Box>
              {stepTexts.step2}
              <Box sx={{
                display: 'flex',
                justifyContent: 'center',
                mt: 3,
              }}>
                <KeyboardArrowDownIcon 
                  sx={{ 
                    fontSize: { xs: '28px', sm: '32px', md: '36px' },
                    color: '#DD203C',
                    animation: 'bounce 1.5s ease-in-out infinite',
                  }}
                />
              </Box>
            </>
          )}

          {/* Contenu étape 3 */}
          {currentStep === 3 && (
            <>
              <Box sx={{ 
                fontFamily: '"Sanomat Web Medium Regular"',
                fontSize: { xs: '16px', sm: '20px', md: '24px' },
                fontWeight: 'bold',
                mb: 2,
                color: '#DD203C'
              }}>
                Les économies de grands espaces
              </Box>
              {stepTexts.step1}
              <Box sx={{
                display: 'flex',
                justifyContent: 'center',
                mt: 3,
              }}>
                <KeyboardArrowDownIcon 
                  sx={{ 
                    fontSize: { xs: '28px', sm: '32px', md: '36px' },
                    color: '#DD203C',
                    animation: 'bounce 1.5s ease-in-out infinite',
                  }}
                />
              </Box>
            </>
          )}
        </Box>
      </Box>
    </Box>
  )
}

export default App
